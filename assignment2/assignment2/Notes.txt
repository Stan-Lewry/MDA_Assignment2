
mapTiles:

The tiles that will be used to represent the world
screenX and Y will be used for rendering the tiles and should make rendering more efficient,
with their screen poistion being calculated when the map is generated instead of on each render.
This should also make the render function simpler to write. The positions can be offset at render
time for drawing UI Elements. The renderSize will have to remain static.

Does not make rendering more efficient - still need nested for loop, still needs to access
each tile -- perhaps only makes it easier to read/write

values:
	screenX
	screenY
	typeX
	typeY
	blocked
	selected
	moveRange
	attackRange

mapTile tile type - int that refers to position in sprite sheet. multiply by the size of each tile IN THE SHEET
Currently the selected tile is indicated by a bool - this will need to be turned to false
by checking every tile in the map whena  new tile is clicked - inneficient 


Tile Types:
	0	test tile


each tile is currently 32x32px
test tile is first element in the sprite sheet at 0,0

NOTE: in standard nested for loop - outer loop represents up/down in the array or y value, inner loop is X value


int SDL_RenderCopy(SDL_Renderer*   renderer,
                   SDL_Texture*    texture,
                   const SDL_Rect* srcrect,
                   const SDL_Rect* dstrect)



Currently selected tile in yellow
Attach range tiles in red
Move range tiles in green? or blue?


TODO:
	DONE implement input hadling - SDL_QUIT
	DONE make proper game loop
	DONE make tiles clickable - need new sprite for higlighted tile
	Begin to consider framework - move input handling to a seperate class
	Implement withinRange / A*





#include "SDLUtils.h"


//#define mapW 10
//#define mapH 10

const int mapW = 15;
const int mapH = 15;
const int mapSize = mapW * mapH;

bool globalRunning;

SDL_Texture* mapTileTexture = NULL;

SDL_Event evnt;

SDLUtils* sdlU;

struct mapTile{
	int screenX;
	int screenY;
	int typeX;
	int typeY;
	bool blocked;
	bool selected;
	bool moveRange;
	bool attackRange;
};


int tileSize = 32;
mapTile map[mapW][mapH];


SDL_Texture* loadPNG(char path[]){
	printf("loading: %s\n", path);
	SDL_Surface* tempSurface = IMG_Load(path);
	SDL_Texture* texture = SDL_CreateTextureFromSurface(sdlU->rend, tempSurface);
	SDL_FreeSurface(tempSurface);
	printf("Done!\n");
	return texture;
}

void initTextures(){
	mapTileTexture = loadPNG("Assets/tiles01.png");
}

void initMap(){
	for (int i = 0; i < mapH; i++){
		for (int j = 0; j < mapW; j++){
			mapTile newTile;
			newTile.screenX = j * tileSize;
			newTile.screenY = i * tileSize;
			newTile.typeX = 0;
			newTile.typeY = 0;
			newTile.blocked = false;
			newTile.selected = false;
			newTile.moveRange = false;
			newTile.attackRange = false;
			map[i][j] = newTile;
		}
	}
}

void checkClick(int clickX, int clickY){
	for (int i = 0; i < mapH; i++){
		for (int j = 0; j < mapW; j++){
			map[i][j].selected = false;
			if (clickX > map[i][j].screenX && clickX < map[i][j].screenX + tileSize){
				if (clickY > map[i][j].screenY && clickY < map[i][j].screenY + tileSize){
					map[i][j].selected = true;
				}
			}
		}
	}
}

void handleEvents(){
	while (SDL_PollEvent(&evnt)){
		switch(evnt.type){
		case SDL_QUIT:
			globalRunning = false;
			break;
		case SDL_MOUSEBUTTONDOWN:
			int x, y;
			SDL_GetMouseState(&x, &y);
			checkClick(x, y);
			break;
		default:
			break;
		}
	}
}


void renderMap(){


}

int main(int argv, char* argc[]){

	sdlU = new SDLUtils();
	globalRunning = sdlU->initSDL();

	initMap();
	initTextures();


	while (globalRunning){
		handleEvents();
		renderMap();
	}

	return 0;
}